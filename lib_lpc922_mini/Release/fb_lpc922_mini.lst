                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.1.4 #7479 (Mar 23 2012) (MINGW32)
                              4 ; This file was generated Fri Oct 19 21:19:00 2012
                              5 ;--------------------------------------------------------
                              6 	.module fb_lpc922_mini
                              7 	.optsdcc -mmcs51 --model-small
                              8 	
                              9 ;--------------------------------------------------------
                             10 ; Public variables in this module
                             11 ;--------------------------------------------------------
                             12 	.globl _eeprom
                             13 	.globl _userram
                             14 	.globl _build_tel
                             15 	.globl _read_value_req
                             16 	.globl _write_value_req
                             17 	.globl _gapos_in_gat
                             18 	.globl _P3_1
                             19 	.globl _P3_0
                             20 	.globl _P1_7
                             21 	.globl _P1_6
                             22 	.globl _P1_5
                             23 	.globl _P1_4
                             24 	.globl _P1_3
                             25 	.globl _P1_2
                             26 	.globl _P1_1
                             27 	.globl _P1_0
                             28 	.globl _P0_7
                             29 	.globl _P0_6
                             30 	.globl _P0_5
                             31 	.globl _P0_4
                             32 	.globl _P0_3
                             33 	.globl _P0_2
                             34 	.globl _P0_1
                             35 	.globl _P0_0
                             36 	.globl _I2CON_0
                             37 	.globl _I2CON_2
                             38 	.globl _I2CON_3
                             39 	.globl _I2CON_4
                             40 	.globl _I2CON_5
                             41 	.globl _I2CON_6
                             42 	.globl _SCON_7
                             43 	.globl _SCON_6
                             44 	.globl _SCON_5
                             45 	.globl _SCON_4
                             46 	.globl _SCON_3
                             47 	.globl _SCON_2
                             48 	.globl _SCON_1
                             49 	.globl _SCON_0
                             50 	.globl _IP0_0
                             51 	.globl _IP0_1
                             52 	.globl _IP0_2
                             53 	.globl _IP0_3
                             54 	.globl _IP0_4
                             55 	.globl _IP0_5
                             56 	.globl _IP0_6
                             57 	.globl _IP1_0
                             58 	.globl _IP1_1
                             59 	.globl _IP1_2
                             60 	.globl _IP1_6
                             61 	.globl _IEN1_0
                             62 	.globl _IEN1_1
                             63 	.globl _IEN1_2
                             64 	.globl _IEN0_0
                             65 	.globl _IEN0_1
                             66 	.globl _IEN0_2
                             67 	.globl _IEN0_3
                             68 	.globl _IEN0_4
                             69 	.globl _IEN0_5
                             70 	.globl _IEN0_6
                             71 	.globl _IEN0_7
                             72 	.globl _TCON_0
                             73 	.globl _TCON_1
                             74 	.globl _TCON_2
                             75 	.globl _TCON_3
                             76 	.globl _TCON_4
                             77 	.globl _TCON_5
                             78 	.globl _TCON_6
                             79 	.globl _TCON_7
                             80 	.globl _PSW_7
                             81 	.globl _PSW_6
                             82 	.globl _PSW_5
                             83 	.globl _PSW_4
                             84 	.globl _PSW_3
                             85 	.globl _PSW_2
                             86 	.globl _PSW_1
                             87 	.globl _PSW_0
                             88 	.globl _IEN1
                             89 	.globl _IP0H
                             90 	.globl _WFEED2
                             91 	.globl _WFEED1
                             92 	.globl _WDL
                             93 	.globl _WDCON
                             94 	.globl _TRIM
                             95 	.globl _TAMOD
                             96 	.globl _SSTAT
                             97 	.globl _RTCL
                             98 	.globl _RTCH
                             99 	.globl _RTCCON
                            100 	.globl _RSTSRC
                            101 	.globl _PT0AD
                            102 	.globl _PCONA
                            103 	.globl _P3M2
                            104 	.globl _P3M1
                            105 	.globl _P1M2
                            106 	.globl _P1M1
                            107 	.globl _P0M2
                            108 	.globl _P0M1
                            109 	.globl _KBPATN
                            110 	.globl _KBMASK
                            111 	.globl _KBCON
                            112 	.globl _IP1H
                            113 	.globl _IP1
                            114 	.globl _I2STAT
                            115 	.globl _I2SCLL
                            116 	.globl _I2SCLH
                            117 	.globl _I2DAT
                            118 	.globl _I2CON
                            119 	.globl _I2ADR
                            120 	.globl _FMDATA
                            121 	.globl _FMCON
                            122 	.globl _FMADRL
                            123 	.globl _FMADRH
                            124 	.globl _DIVM
                            125 	.globl _CMP2
                            126 	.globl _CMP1
                            127 	.globl _BRGCON
                            128 	.globl _BRGR1
                            129 	.globl _BRGR0
                            130 	.globl _SADEN
                            131 	.globl _SADDR
                            132 	.globl _AUXR1
                            133 	.globl _SBUF
                            134 	.globl _SCON
                            135 	.globl _IP0
                            136 	.globl _IEN0
                            137 	.globl _TH1
                            138 	.globl _TH0
                            139 	.globl _TL1
                            140 	.globl _TL0
                            141 	.globl _TMOD
                            142 	.globl _TCON
                            143 	.globl _PCON
                            144 	.globl _DPH
                            145 	.globl _DPL
                            146 	.globl _SP
                            147 	.globl _B
                            148 	.globl _ACC
                            149 	.globl _PSW
                            150 	.globl _P3
                            151 	.globl _P1
                            152 	.globl _P0
                            153 	.globl _inc_pcount
                            154 	.globl _connected
                            155 	.globl _transparency
                            156 	.globl _send_nack
                            157 	.globl _send_ack
                            158 	.globl _wait_for_ack
                            159 	.globl _fbtx_bit
                            160 	.globl _auto_ack
                            161 	.globl _tel_sent
                            162 	.globl _tel_arrived
                            163 	.globl _its_me
                            164 	.globl _nack
                            165 	.globl _ack
                            166 	.globl _fb_parity
                            167 	.globl _interrupted
                            168 	.globl _parity_ok
                            169 	.globl _status60
                            170 	.globl _tx_nextsend
                            171 	.globl _tx_nextwrite
                            172 	.globl _repeat_count
                            173 	.globl _fb_state
                            174 	.globl _fb_pattern
                            175 	.globl _fbrx_byte
                            176 	.globl _cs
                            177 	.globl _telpos
                            178 	.globl _tx_buffer
                            179 	.globl _telegramm
                            180 	.globl _senders_pcount
                            181 	.globl _mem_adrl
                            182 	.globl _mem_adrh
                            183 	.globl _mem_length
                            184 	.globl _pcount
                            185 	.globl _conl
                            186 	.globl _conh
                            187 	.globl _X1_int
                            188 	.globl _T1_int
                            189 	.globl _init_rx
                            190 	.globl _init_tx
                            191 	.globl _send_obj_value
                            192 	.globl _process_tel
                            193 	.globl _restart_hw
                            194 ;--------------------------------------------------------
                            195 ; special function registers
                            196 ;--------------------------------------------------------
                            197 	.area RSEG    (ABS,DATA)
   0000                     198 	.org 0x0000
                    0080    199 _P0	=	0x0080
                    0090    200 _P1	=	0x0090
                    00B0    201 _P3	=	0x00b0
                    00D0    202 _PSW	=	0x00d0
                    00E0    203 _ACC	=	0x00e0
                    00F0    204 _B	=	0x00f0
                    0081    205 _SP	=	0x0081
                    0082    206 _DPL	=	0x0082
                    0083    207 _DPH	=	0x0083
                    0087    208 _PCON	=	0x0087
                    0088    209 _TCON	=	0x0088
                    0089    210 _TMOD	=	0x0089
                    008A    211 _TL0	=	0x008a
                    008B    212 _TL1	=	0x008b
                    008C    213 _TH0	=	0x008c
                    008D    214 _TH1	=	0x008d
                    00A8    215 _IEN0	=	0x00a8
                    00B8    216 _IP0	=	0x00b8
                    0098    217 _SCON	=	0x0098
                    0099    218 _SBUF	=	0x0099
                    00A2    219 _AUXR1	=	0x00a2
                    00A9    220 _SADDR	=	0x00a9
                    00B9    221 _SADEN	=	0x00b9
                    00BE    222 _BRGR0	=	0x00be
                    00BF    223 _BRGR1	=	0x00bf
                    00BD    224 _BRGCON	=	0x00bd
                    00AC    225 _CMP1	=	0x00ac
                    00AD    226 _CMP2	=	0x00ad
                    0095    227 _DIVM	=	0x0095
                    00E7    228 _FMADRH	=	0x00e7
                    00E6    229 _FMADRL	=	0x00e6
                    00E4    230 _FMCON	=	0x00e4
                    00E5    231 _FMDATA	=	0x00e5
                    00DB    232 _I2ADR	=	0x00db
                    00D8    233 _I2CON	=	0x00d8
                    00DA    234 _I2DAT	=	0x00da
                    00DD    235 _I2SCLH	=	0x00dd
                    00DC    236 _I2SCLL	=	0x00dc
                    00D9    237 _I2STAT	=	0x00d9
                    00F8    238 _IP1	=	0x00f8
                    00F7    239 _IP1H	=	0x00f7
                    0094    240 _KBCON	=	0x0094
                    0086    241 _KBMASK	=	0x0086
                    0093    242 _KBPATN	=	0x0093
                    0084    243 _P0M1	=	0x0084
                    0085    244 _P0M2	=	0x0085
                    0091    245 _P1M1	=	0x0091
                    0092    246 _P1M2	=	0x0092
                    00B1    247 _P3M1	=	0x00b1
                    00B2    248 _P3M2	=	0x00b2
                    00B5    249 _PCONA	=	0x00b5
                    00F6    250 _PT0AD	=	0x00f6
                    00DF    251 _RSTSRC	=	0x00df
                    00D1    252 _RTCCON	=	0x00d1
                    00D2    253 _RTCH	=	0x00d2
                    00D3    254 _RTCL	=	0x00d3
                    00BA    255 _SSTAT	=	0x00ba
                    008F    256 _TAMOD	=	0x008f
                    0096    257 _TRIM	=	0x0096
                    00A7    258 _WDCON	=	0x00a7
                    00C1    259 _WDL	=	0x00c1
                    00C2    260 _WFEED1	=	0x00c2
                    00C3    261 _WFEED2	=	0x00c3
                    00B7    262 _IP0H	=	0x00b7
                    00E8    263 _IEN1	=	0x00e8
                            264 ;--------------------------------------------------------
                            265 ; special function bits
                            266 ;--------------------------------------------------------
                            267 	.area RSEG    (ABS,DATA)
   0000                     268 	.org 0x0000
                    00D0    269 _PSW_0	=	0x00d0
                    00D1    270 _PSW_1	=	0x00d1
                    00D2    271 _PSW_2	=	0x00d2
                    00D3    272 _PSW_3	=	0x00d3
                    00D4    273 _PSW_4	=	0x00d4
                    00D5    274 _PSW_5	=	0x00d5
                    00D6    275 _PSW_6	=	0x00d6
                    00D7    276 _PSW_7	=	0x00d7
                    008F    277 _TCON_7	=	0x008f
                    008E    278 _TCON_6	=	0x008e
                    008D    279 _TCON_5	=	0x008d
                    008C    280 _TCON_4	=	0x008c
                    008B    281 _TCON_3	=	0x008b
                    008A    282 _TCON_2	=	0x008a
                    0089    283 _TCON_1	=	0x0089
                    0088    284 _TCON_0	=	0x0088
                    00AF    285 _IEN0_7	=	0x00af
                    00AE    286 _IEN0_6	=	0x00ae
                    00AD    287 _IEN0_5	=	0x00ad
                    00AC    288 _IEN0_4	=	0x00ac
                    00AB    289 _IEN0_3	=	0x00ab
                    00AA    290 _IEN0_2	=	0x00aa
                    00A9    291 _IEN0_1	=	0x00a9
                    00A8    292 _IEN0_0	=	0x00a8
                    00EA    293 _IEN1_2	=	0x00ea
                    00E9    294 _IEN1_1	=	0x00e9
                    00E8    295 _IEN1_0	=	0x00e8
                    00FE    296 _IP1_6	=	0x00fe
                    00FA    297 _IP1_2	=	0x00fa
                    00F9    298 _IP1_1	=	0x00f9
                    00F8    299 _IP1_0	=	0x00f8
                    00BE    300 _IP0_6	=	0x00be
                    00BD    301 _IP0_5	=	0x00bd
                    00BC    302 _IP0_4	=	0x00bc
                    00BB    303 _IP0_3	=	0x00bb
                    00BA    304 _IP0_2	=	0x00ba
                    00B9    305 _IP0_1	=	0x00b9
                    00B8    306 _IP0_0	=	0x00b8
                    0098    307 _SCON_0	=	0x0098
                    0099    308 _SCON_1	=	0x0099
                    009A    309 _SCON_2	=	0x009a
                    009B    310 _SCON_3	=	0x009b
                    009C    311 _SCON_4	=	0x009c
                    009D    312 _SCON_5	=	0x009d
                    009E    313 _SCON_6	=	0x009e
                    009F    314 _SCON_7	=	0x009f
                    00DE    315 _I2CON_6	=	0x00de
                    00DD    316 _I2CON_5	=	0x00dd
                    00DC    317 _I2CON_4	=	0x00dc
                    00DB    318 _I2CON_3	=	0x00db
                    00DA    319 _I2CON_2	=	0x00da
                    00D8    320 _I2CON_0	=	0x00d8
                    0080    321 _P0_0	=	0x0080
                    0081    322 _P0_1	=	0x0081
                    0082    323 _P0_2	=	0x0082
                    0083    324 _P0_3	=	0x0083
                    0084    325 _P0_4	=	0x0084
                    0085    326 _P0_5	=	0x0085
                    0086    327 _P0_6	=	0x0086
                    0087    328 _P0_7	=	0x0087
                    0090    329 _P1_0	=	0x0090
                    0091    330 _P1_1	=	0x0091
                    0092    331 _P1_2	=	0x0092
                    0093    332 _P1_3	=	0x0093
                    0094    333 _P1_4	=	0x0094
                    0095    334 _P1_5	=	0x0095
                    0096    335 _P1_6	=	0x0096
                    0097    336 _P1_7	=	0x0097
                    00B0    337 _P3_0	=	0x00b0
                    00B1    338 _P3_1	=	0x00b1
                            339 ;--------------------------------------------------------
                            340 ; overlayable register banks
                            341 ;--------------------------------------------------------
                            342 	.area REG_BANK_0	(REL,OVR,DATA)
   0000                     343 	.ds 8
                            344 ;--------------------------------------------------------
                            345 ; overlayable bit register bank
                            346 ;--------------------------------------------------------
                            347 	.area BIT_BANK	(REL,OVR,DATA)
   0000                     348 bits:
   0000                     349 	.ds 1
                    8000    350 	b0 = bits[0]
                    8100    351 	b1 = bits[1]
                    8200    352 	b2 = bits[2]
                    8300    353 	b3 = bits[3]
                    8400    354 	b4 = bits[4]
                    8500    355 	b5 = bits[5]
                    8600    356 	b6 = bits[6]
                    8700    357 	b7 = bits[7]
                            358 ;--------------------------------------------------------
                            359 ; internal ram data
                            360 ;--------------------------------------------------------
                            361 	.area DSEG    (DATA)
   0000                     362 _conh::
   0000                     363 	.ds 1
   0001                     364 _conl::
   0001                     365 	.ds 1
   0002                     366 _pcount::
   0002                     367 	.ds 1
   0003                     368 _mem_length::
   0003                     369 	.ds 1
   0004                     370 _mem_adrh::
   0004                     371 	.ds 1
   0005                     372 _mem_adrl::
   0005                     373 	.ds 1
   0006                     374 _senders_pcount::
   0006                     375 	.ds 1
   0007                     376 _telegramm::
   0007                     377 	.ds 23
   001E                     378 _tx_buffer::
   001E                     379 	.ds 8
   0026                     380 _telpos::
   0026                     381 	.ds 1
   0027                     382 _cs::
   0027                     383 	.ds 1
   0028                     384 _fbrx_byte::
   0028                     385 	.ds 1
   0029                     386 _fb_pattern::
   0029                     387 	.ds 1
   002A                     388 _fb_state::
   002A                     389 	.ds 1
   002B                     390 _repeat_count::
   002B                     391 	.ds 1
   002C                     392 _tx_nextwrite::
   002C                     393 	.ds 1
   002D                     394 _tx_nextsend::
   002D                     395 	.ds 1
   002E                     396 _status60::
   002E                     397 	.ds 1
                            398 ;--------------------------------------------------------
                            399 ; overlayable items in internal ram 
                            400 ;--------------------------------------------------------
                            401 ;--------------------------------------------------------
                            402 ; indirectly addressable internal ram data
                            403 ;--------------------------------------------------------
                            404 	.area ISEG    (DATA)
                            405 ;--------------------------------------------------------
                            406 ; absolute internal ram data
                            407 ;--------------------------------------------------------
                            408 	.area IABS    (ABS,DATA)
                            409 	.area IABS    (ABS,DATA)
                            410 ;--------------------------------------------------------
                            411 ; bit data
                            412 ;--------------------------------------------------------
                            413 	.area BSEG    (BIT)
   0000                     414 _parity_ok::
   0000                     415 	.ds 1
   0001                     416 _interrupted::
   0001                     417 	.ds 1
   0002                     418 _fb_parity::
   0002                     419 	.ds 1
   0003                     420 _ack::
   0003                     421 	.ds 1
   0004                     422 _nack::
   0004                     423 	.ds 1
   0005                     424 _its_me::
   0005                     425 	.ds 1
   0006                     426 _tel_arrived::
   0006                     427 	.ds 1
   0007                     428 _tel_sent::
   0007                     429 	.ds 1
   0008                     430 _auto_ack::
   0008                     431 	.ds 1
   0009                     432 _fbtx_bit::
   0009                     433 	.ds 1
   000A                     434 _wait_for_ack::
   000A                     435 	.ds 1
   000B                     436 _send_ack::
   000B                     437 	.ds 1
   000C                     438 _send_nack::
   000C                     439 	.ds 1
   000D                     440 _transparency::
   000D                     441 	.ds 1
   000E                     442 _connected::
   000E                     443 	.ds 1
   000F                     444 _inc_pcount::
   000F                     445 	.ds 1
                            446 ;--------------------------------------------------------
                            447 ; paged external ram data
                            448 ;--------------------------------------------------------
                            449 	.area PSEG    (PAG,XDATA)
                            450 ;--------------------------------------------------------
                            451 ; external ram data
                            452 ;--------------------------------------------------------
                            453 	.area XSEG    (XDATA)
                            454 ;--------------------------------------------------------
                            455 ; absolute external ram data
                            456 ;--------------------------------------------------------
                            457 	.area XABS    (ABS,XDATA)
                            458 ;--------------------------------------------------------
                            459 ; external initialized ram data
                            460 ;--------------------------------------------------------
                            461 	.area XISEG   (XDATA)
                            462 	.area HOME    (CODE)
                            463 	.area GSINIT0 (CODE)
                            464 	.area GSINIT1 (CODE)
                            465 	.area GSINIT2 (CODE)
                            466 	.area GSINIT3 (CODE)
                            467 	.area GSINIT4 (CODE)
                            468 	.area GSINIT5 (CODE)
                            469 	.area GSINIT  (CODE)
                            470 	.area GSFINAL (CODE)
                            471 	.area CSEG    (CODE)
                            472 ;--------------------------------------------------------
                            473 ; global & static initialisations
                            474 ;--------------------------------------------------------
                            475 	.area HOME    (CODE)
                            476 	.area GSINIT  (CODE)
                            477 	.area GSFINAL (CODE)
                            478 	.area GSINIT  (CODE)
                            479 ;--------------------------------------------------------
                            480 ; Home
                            481 ;--------------------------------------------------------
                            482 	.area HOME    (CODE)
                            483 	.area HOME    (CODE)
                            484 ;--------------------------------------------------------
                            485 ; code
                            486 ;--------------------------------------------------------
                            487 	.area CSEG    (CODE)
                            488 ;------------------------------------------------------------
                            489 ;Allocation info for local variables in function 'X1_int'
                            490 ;------------------------------------------------------------
                            491 ;	../fb_lpc922_mini.c:60: void X1_int(void) __interrupt (2)		// Flanke des Startbits löst int1 aus
                            492 ;	-----------------------------------------
                            493 ;	 function X1_int
                            494 ;	-----------------------------------------
   0000                     495 _X1_int:
                    0007    496 	ar7 = 0x07
                    0006    497 	ar6 = 0x06
                    0005    498 	ar5 = 0x05
                    0004    499 	ar4 = 0x04
                    0003    500 	ar3 = 0x03
                    0002    501 	ar2 = 0x02
                    0001    502 	ar1 = 0x01
                    0000    503 	ar0 = 0x00
   0000 C0 E0               504 	push	acc
   0002 C0 D0               505 	push	psw
                            506 ;	../fb_lpc922_mini.c:63: EX1=0;			// int1 stoppen								1 cycle = 0,27127us
   0004 C2 AA               507 	clr	_IEN0_2
                            508 ;	../fb_lpc922_mini.c:64: TR1=0;			// Timer 1 stoppen
   0006 C2 8E               509 	clr	_TCON_6
                            510 ;	../fb_lpc922_mini.c:65: TMOD=(TMOD & 0x0F) + 0x20;	// Timer 1 als 8-Bit autoreload
   0008 74 0F               511 	mov	a,#0x0F
   000A 55 89               512 	anl	a,_TMOD
   000C 24 20               513 	add	a,#0x20
   000E F5 89               514 	mov	_TMOD,a
                            515 ;	../fb_lpc922_mini.c:66: TL1=53;//108;//128;		// Timer laden so dass in state 2 bei 75µs abgefragt wird
   0010 75 8B 35            516 	mov	_TL1,#0x35
                            517 ;	../fb_lpc922_mini.c:67: TH1=128;//128;			// autoreload auf 35µs setzen (gilt für sprung von 2 auf 3)
   0013 75 8D 80            518 	mov	_TH1,#0x80
                            519 ;	../fb_lpc922_mini.c:68: TF1=0;			// Timer1-flag löschen						1 cycle
   0016 C2 8F               520 	clr	_TCON_7
                            521 ;	../fb_lpc922_mini.c:69: TR1=1;			// Timer1 starten							1 cycle
   0018 D2 8E               522 	setb	_TCON_6
                            523 ;	../fb_lpc922_mini.c:70: ET1=1;			// Timer1-int aktiv							1 cycle
   001A D2 AB               524 	setb	_IEN0_3
                            525 ;	../fb_lpc922_mini.c:71: fb_state=2;		// nächster state
   001C 75*2A 02            526 	mov	_fb_state,#0x02
                            527 ;	../fb_lpc922_mini.c:72: fb_parity=0;	// Parity Bit löschen
   001F C2*02               528 	clr	_fb_parity
                            529 ;	../fb_lpc922_mini.c:73: parity_ok=1;	// wird bei Fehler gelöscht
   0021 D2*00               530 	setb	_parity_ok
                            531 ;	../fb_lpc922_mini.c:74: fb_pattern=0;
   0023 75*29 00            532 	mov	_fb_pattern,#0x00
                            533 ;	../fb_lpc922_mini.c:75: fbrx_byte=0;
   0026 75*28 00            534 	mov	_fbrx_byte,#0x00
                            535 ;	../fb_lpc922_mini.c:76: interrupted=1;	// signalisiert app, dass unterbrochen wurde
   0029 D2*01               536 	setb	_interrupted
   002B D0 D0               537 	pop	psw
   002D D0 E0               538 	pop	acc
   002F 32                  539 	reti
                            540 ;	eliminated unneeded mov psw,# (no regs used in bank)
                            541 ;	eliminated unneeded push/pop dpl
                            542 ;	eliminated unneeded push/pop dph
                            543 ;	eliminated unneeded push/pop b
                            544 ;------------------------------------------------------------
                            545 ;Allocation info for local variables in function 'T1_int'
                            546 ;------------------------------------------------------------
                            547 ;fbrx_bit                  Allocated to registers b0 
                            548 ;send_byte                 Allocated to registers r7 
                            549 ;------------------------------------------------------------
                            550 ;	../fb_lpc922_mini.c:81: void T1_int(void) __interrupt (3) 	// Timer 1 Interrupt
                            551 ;	-----------------------------------------
                            552 ;	 function T1_int
                            553 ;	-----------------------------------------
   0030                     554 _T1_int:
   0030 C0*00               555 	push	bits
   0032 C0 E0               556 	push	acc
   0034 C0 F0               557 	push	b
   0036 C0 82               558 	push	dpl
   0038 C0 83               559 	push	dph
   003A C0 07               560 	push	(0+7)
   003C C0 06               561 	push	(0+6)
   003E C0 05               562 	push	(0+5)
   0040 C0 04               563 	push	(0+4)
   0042 C0 03               564 	push	(0+3)
   0044 C0 02               565 	push	(0+2)
   0046 C0 01               566 	push	(0+1)
   0048 C0 00               567 	push	(0+0)
   004A C0 D0               568 	push	psw
   004C 75 D0 00            569 	mov	psw,#0x00
                            570 ;	../fb_lpc922_mini.c:87: switch (fb_state){
   004F E5*2A               571 	mov	a,_fb_state
   0051 FF                  572 	mov	r7,a
   0052 24 F1               573 	add	a,#0xff - 0x0E
   0054 50 03               574 	jnc	00322$
   0056 02s03r5D            575 	ljmp	00219$
   0059                     576 00322$:
   0059 EF                  577 	mov	a,r7
   005A 2F                  578 	add	a,r7
   005B 2F                  579 	add	a,r7
   005C 90s00r60            580 	mov	dptr,#00323$
   005F 73                  581 	jmp	@a+dptr
   0060                     582 00323$:
   0060 02s00r8D            583 	ljmp	00101$
   0063 02s03r5D            584 	ljmp	00219$
   0066 02s01r00            585 	ljmp	00115$
   0069 02s01rBA            586 	ljmp	00151$
   006C 02s01rC3            587 	ljmp	00152$
   006F 02s02r48            588 	ljmp	00175$
   0072 02s03r5D            589 	ljmp	00219$
   0075 02s03r5D            590 	ljmp	00219$
   0078 02s03r5D            591 	ljmp	00219$
   007B 02s03r5D            592 	ljmp	00219$
   007E 02s02r6C            593 	ljmp	00182$
   0081 02s02rD4            594 	ljmp	00203$
   0084 02s03r5D            595 	ljmp	00219$
   0087 02s02rF8            596 	ljmp	00210$
   008A 02s03r46            597 	ljmp	00218$
                            598 ;	../fb_lpc922_mini.c:91: case 0:
   008D                     599 00101$:
                            600 ;	../fb_lpc922_mini.c:92: TR1=0;			// Timer 1 stoppen
   008D C2 8E               601 	clr	_TCON_6
                            602 ;	../fb_lpc922_mini.c:93: TMOD=(TMOD & 0x0F) + 0x20;	// Timer 1 als 8-Bit autoreload
   008F 74 0F               603 	mov	a,#0x0F
   0091 55 89               604 	anl	a,_TMOD
   0093 24 20               605 	add	a,#0x20
   0095 F5 89               606 	mov	_TMOD,a
                            607 ;	../fb_lpc922_mini.c:94: TL1=128;		// Timer laden
   0097 75 8B 80            608 	mov	_TL1,#0x80
                            609 ;	../fb_lpc922_mini.c:95: TH1=128;
   009A 75 8D 80            610 	mov	_TH1,#0x80
                            611 ;	../fb_lpc922_mini.c:96: TF1=0;			// Timer1-flag löschen						1 cycle
   009D C2 8F               612 	clr	_TCON_7
                            613 ;	../fb_lpc922_mini.c:97: TR1=1;			// Timer1 starten							1 cycle
   009F D2 8E               614 	setb	_TCON_6
                            615 ;	../fb_lpc922_mini.c:98: if(tx_nextsend != tx_nextwrite) { 			// wenn zu sendendes Objekt vorhanden
   00A1 E5*2C               616 	mov	a,_tx_nextwrite
   00A3 B5*2D 02            617 	cjne	a,_tx_nextsend,00324$
   00A6 80 51               618 	sjmp	00113$
   00A8                     619 00324$:
                            620 ;	../fb_lpc922_mini.c:99: if(build_tel(tx_buffer[tx_nextsend])) {	// wenn Telegramm gebildet werden konnte
   00A8 E5*2D               621 	mov	a,_tx_nextsend
   00AA 24r1E               622 	add	a,#_tx_buffer
   00AC F9                  623 	mov	r1,a
   00AD 87 82               624 	mov	dpl,@r1
   00AF 12s00r00            625 	lcall	_build_tel
   00B2 50 3D               626 	jnc	00110$
                            627 ;	../fb_lpc922_mini.c:100: EX1=0; 				//Um zu vermeiden dass man in die Abfrage hinein-empfängt
   00B4 C2 AA               628 	clr	_IEN0_2
                            629 ;	../fb_lpc922_mini.c:101: if(!fb_state) { 	//nur bilden wenn vorher kein rx_intit durch ext int kam
   00B6 E5*2A               630 	mov	a,_fb_state
   00B8 70 32               631 	jnz	00108$
                            632 ;	../fb_lpc922_mini.c:102: if((tx_buffer[tx_nextsend]&0x20)==0) {	// wenn erstmaliges Senden des Objektes
   00BA E5*2D               633 	mov	a,_tx_nextsend
   00BC 24r1E               634 	add	a,#_tx_buffer
   00BE F9                  635 	mov	r1,a
   00BF E7                  636 	mov	a,@r1
   00C0 FF                  637 	mov	r7,a
   00C1 20 E5 07            638 	jb	acc.5,00103$
                            639 ;	../fb_lpc922_mini.c:103: tx_buffer[tx_nextsend]|=0x20;		// Bit für "wird gerade gesendet"
   00C4 74 20               640 	mov	a,#0x20
   00C6 4F                  641 	orl	a,r7
   00C7 F7                  642 	mov	@r1,a
                            643 ;	../fb_lpc922_mini.c:104: repeat_count=0;						// Wiederholungszähler für nicht geackte Telegramme
   00C8 75*2B 00            644 	mov	_repeat_count,#0x00
   00CB                     645 00103$:
                            646 ;	../fb_lpc922_mini.c:106: if (repeat_count<4) init_tx();		// Senden starten
   00CB 74 FC               647 	mov	a,#0x100 - 0x04
   00CD 25*2B               648 	add	a,_repeat_count
   00CF 40 05               649 	jc	00105$
   00D1 12s03rA8            650 	lcall	_init_tx
   00D4 80 16               651 	sjmp	00108$
   00D6                     652 00105$:
                            653 ;	../fb_lpc922_mini.c:108: tx_nextsend++;
   00D6 05*2D               654 	inc	_tx_nextsend
                            655 ;	../fb_lpc922_mini.c:109: tx_nextsend&=0x07;
   00D8 53*2D 07            656 	anl	_tx_nextsend,#0x07
                            657 ;	../fb_lpc922_mini.c:110: wait_for_ack=0;
   00DB C2*0A               658 	clr	_wait_for_ack
                            659 ;	../fb_lpc922_mini.c:111: inc_pcount=0;
   00DD C2*0F               660 	clr	_inc_pcount
                            661 ;	../fb_lpc922_mini.c:112: init_rx();
   00DF 12s03r7C            662 	lcall	_init_rx
                            663 ;	../fb_lpc922_mini.c:113: TR1=0;		// hier nicht noch einmal die ganze busfree Zeit warten
   00E2 C2 8E               664 	clr	_TCON_6
                            665 ;	../fb_lpc922_mini.c:114: TH1=0xF0;
   00E4 75 8D F0            666 	mov	_TH1,#0xF0
                            667 ;	../fb_lpc922_mini.c:115: TL1=0x00;
   00E7 75 8B 00            668 	mov	_TL1,#0x00
                            669 ;	../fb_lpc922_mini.c:116: TR1=1;
   00EA D2 8E               670 	setb	_TCON_6
   00EC                     671 00108$:
                            672 ;	../fb_lpc922_mini.c:119: EX1=1;	// ext1 int einschalten falls Empfang...
   00EC D2 AA               673 	setb	_IEN0_2
   00EE 02s03r5D            674 	ljmp	00219$
   00F1                     675 00110$:
                            676 ;	../fb_lpc922_mini.c:122: tx_nextsend++; //hier Zeiger erhöhen wenn Telegramm nicht gebildet werden konnte
   00F1 05*2D               677 	inc	_tx_nextsend
                            678 ;	../fb_lpc922_mini.c:123: tx_nextsend&=0x07;
   00F3 53*2D 07            679 	anl	_tx_nextsend,#0x07
   00F6 02s03r5D            680 	ljmp	00219$
   00F9                     681 00113$:
                            682 ;	../fb_lpc922_mini.c:127: TR1=0;		// nichts mehr zu tun, also statemachine stoppen
   00F9 C2 8E               683 	clr	_TCON_6
                            684 ;	../fb_lpc922_mini.c:128: EX1=1;		// sicherstellen, dass ext. Int. 1 aktiv ist
   00FB D2 AA               685 	setb	_IEN0_2
                            686 ;	../fb_lpc922_mini.c:130: break;
   00FD 02s03r5D            687 	ljmp	00219$
                            688 ;	../fb_lpc922_mini.c:133: case 2: // T=75us
   0100                     689 00115$:
                            690 ;	../fb_lpc922_mini.c:134: fbrx_bit=!IE1;				// Flipflop des ext. Int. 1 auslesen, ist 1 bei fallender Flanke am Pin
   0100 A2 8B               691 	mov	c,_TCON_3
   0102 B3                  692 	cpl	c
   0103 92*00               693 	mov	b0,c
                            694 ;	../fb_lpc922_mini.c:135: IE1=0;						// Flipflop zurücksetzen
   0105 C2 8B               695 	clr	_TCON_3
                            696 ;	../fb_lpc922_mini.c:136: fb_state=3;// nächster state: 3
   0107 75*2A 03            697 	mov	_fb_state,#0x03
                            698 ;	../fb_lpc922_mini.c:137: TH1=0;// reload auf 70µs (zeit swischen state 3 und 2)
   010A 75 8D 00            699 	mov	_TH1,#0x00
                            700 ;	../fb_lpc922_mini.c:138: if(fb_pattern==0) {			// fb_pattern=0 bedeutet, dass bisher nur das Startbit empfangen wurde
   010D E5*29               701 	mov	a,_fb_pattern
   010F 70 0A               702 	jnz	00149$
                            703 ;	../fb_lpc922_mini.c:139: fb_pattern=1;			// 70us nach Startbit, als näcstes kommt Datenbit 0
   0111 75*29 01            704 	mov	_fb_pattern,#0x01
                            705 ;	../fb_lpc922_mini.c:140: ack=0;					// Empfang eines neuen Bytes, also ack/nack Flags zurücksetzen
   0114 C2*03               706 	clr	_ack
                            707 ;	../fb_lpc922_mini.c:141: nack=0;
   0116 C2*04               708 	clr	_nack
   0118 02s03r5D            709 	ljmp	00219$
   011B                     710 00149$:
                            711 ;	../fb_lpc922_mini.c:144: if(fb_pattern<129) {					// Daten-Bit LSB first
   011B 74 7F               712 	mov	a,#0x100 - 0x81
   011D 25*29               713 	add	a,_fb_pattern
   011F 40 1C               714 	jc	00146$
                            715 ;	../fb_lpc922_mini.c:145: if(fbrx_bit) {
   0121 30*00 08            716 	jnb	b0,00117$
                            717 ;	../fb_lpc922_mini.c:146: fb_parity=!fb_parity;			// Paritybit berechnen
   0124 B2*02               718 	cpl	_fb_parity
                            719 ;	../fb_lpc922_mini.c:147: fbrx_byte+=fb_pattern;			// Datenbit speichern
   0126 E5*29               720 	mov	a,_fb_pattern
   0128 25*28               721 	add	a,_fbrx_byte
   012A F5*28               722 	mov	_fbrx_byte,a
   012C                     723 00117$:
                            724 ;	../fb_lpc922_mini.c:149: fb_pattern=fb_pattern<<1;			// nächstes Bit
   012C E5*29               725 	mov	a,_fb_pattern
   012E 25*29               726 	add	a,_fb_pattern
                            727 ;	../fb_lpc922_mini.c:150: if(fb_pattern==0) fb_pattern=129;	// alle Daten-Bits gelesen, Parity-Bit folgt
   0130 F5*29               728 	mov	_fb_pattern,a
   0132 60 03               729 	jz	00332$
   0134 02s03r5D            730 	ljmp	00219$
   0137                     731 00332$:
   0137 75*29 81            732 	mov	_fb_pattern,#0x81
   013A 02s03r5D            733 	ljmp	00219$
   013D                     734 00146$:
                            735 ;	../fb_lpc922_mini.c:153: TR1=0;
   013D C2 8E               736 	clr	_TCON_6
                            737 ;	../fb_lpc922_mini.c:154: TF1=0; //prüfen ob erforderlich!!!
   013F C2 8F               738 	clr	_TCON_7
                            739 ;	../fb_lpc922_mini.c:155: if(fb_parity==fbrx_bit) {				// Parity-Bit OK
   0141 A2*02               740 	mov	c,_fb_parity
   0143 20*00 01            741 	jb	b0,00333$
   0146 B3                  742 	cpl	c
   0147                     743 00333$:
   0147 50 26               744 	jnc	00130$
                            745 ;	../fb_lpc922_mini.c:156: if (telpos==0) {						// erstes empfangenes Byte
   0149 E5*26               746 	mov	a,_telpos
   014B 70 0E               747 	jnz	00125$
                            748 ;	../fb_lpc922_mini.c:157: if (fbrx_byte==0xCC) ack=1;				// ACK empfangen
   014D 74 CC               749 	mov	a,#0xCC
   014F B5*28 02            750 	cjne	a,_fbrx_byte,00121$
   0152 D2*03               751 	setb	_ack
   0154                     752 00121$:
                            753 ;	../fb_lpc922_mini.c:158: if (fbrx_byte==0x0C) nack=1;			// NACK empfangen
   0154 74 0C               754 	mov	a,#0x0C
   0156 B5*28 02            755 	cjne	a,_fbrx_byte,00125$
   0159 D2*04               756 	setb	_nack
   015B                     757 00125$:
                            758 ;	../fb_lpc922_mini.c:160: if (!ack && !nack) {					// Datenbyte empfangen
   015B 20*03 13            759 	jb	_ack,00131$
   015E 20*04 10            760 	jb	_nack,00131$
                            761 ;	../fb_lpc922_mini.c:161: telegramm[telpos]=fbrx_byte;			// Byte speichern
   0161 E5*26               762 	mov	a,_telpos
   0163 24r07               763 	add	a,#_telegramm
   0165 F8                  764 	mov	r0,a
                            765 ;	../fb_lpc922_mini.c:162: cs^=fbrx_byte;							// Checksum berechnen
   0166 E5*28               766 	mov	a,_fbrx_byte
   0168 F6                  767 	mov	@r0,a
   0169 62*27               768 	xrl	_cs,a
                            769 ;	../fb_lpc922_mini.c:163: telpos++;								// Telegrammzeiger erhöhen
   016B 05*26               770 	inc	_telpos
   016D 80 02               771 	sjmp	00131$
   016F                     772 00130$:
                            773 ;	../fb_lpc922_mini.c:166: else parity_ok=0;						// Parity Error
   016F C2*00               774 	clr	_parity_ok
   0171                     775 00131$:
                            776 ;	../fb_lpc922_mini.c:168: if (wait_for_ack) {						// es wird ein ACK erwartet
                            777 ;	../fb_lpc922_mini.c:169: wait_for_ack=0;							// Flag zurücksetzen, da wir es ja gerade abarbeiten
   0171 10*0A 02            778 	jbc	_wait_for_ack,00342$
   0174 80 1D               779 	sjmp	00143$
   0176                     780 00342$:
                            781 ;	../fb_lpc922_mini.c:170: if (ack && parity_ok) {					// ACK empfangen und auch erwartet
   0176 30*03 14            782 	jnb	_ack,00135$
   0179 30*00 11            783 	jnb	_parity_ok,00135$
                            784 ;	../fb_lpc922_mini.c:171: repeat_count=4;						// keine Wiederholtelegramme mehr senden
   017C 75*2B 04            785 	mov	_repeat_count,#0x04
                            786 ;	../fb_lpc922_mini.c:172: if(inc_pcount) {
                            787 ;	../fb_lpc922_mini.c:173: inc_pcount=0;
   017F 10*0F 02            788 	jbc	_inc_pcount,00345$
   0182 80 09               789 	sjmp	00135$
   0184                     790 00345$:
                            791 ;	../fb_lpc922_mini.c:174: pcount+=4;
   0184 E5*02               792 	mov	a,_pcount
   0186 24 04               793 	add	a,#0x04
   0188 F5*02               794 	mov	_pcount,a
                            795 ;	../fb_lpc922_mini.c:175: pcount&=0x3C;
   018A 53*02 3C            796 	anl	_pcount,#0x3C
   018D                     797 00135$:
                            798 ;	../fb_lpc922_mini.c:178: init_rx();
   018D 12s03r7C            799 	lcall	_init_rx
   0190 02s03r5D            800 	ljmp	00219$
   0193                     801 00143$:
                            802 ;	../fb_lpc922_mini.c:181: if (parity_ok && (!ack && !nack)) {		// ganz normales Datenbyte
   0193 30*00 1E            803 	jnb	_parity_ok,00138$
   0196 20*03 1B            804 	jb	_ack,00138$
   0199 20*04 18            805 	jb	_nack,00138$
                            806 ;	../fb_lpc922_mini.c:182: TMOD=(TMOD & 0x0F) +0x10;			// Timer 1 als 16-Bit Timer
   019C 74 0F               807 	mov	a,#0x0F
   019E 55 89               808 	anl	a,_TMOD
   01A0 24 10               809 	add	a,#0x10
   01A2 F5 89               810 	mov	_TMOD,a
                            811 ;	../fb_lpc922_mini.c:183: TH1=0xFA;//0xFA;							// Timer 1 auf Timeout-Position setzen (370us)
   01A4 75 8D FA            812 	mov	_TH1,#0xFA
                            813 ;	../fb_lpc922_mini.c:184: TL1=0x70;//4f 0xAB; (bis hierher sinds 91µs)
   01A7 75 8B 70            814 	mov	_TL1,#0x70
                            815 ;	../fb_lpc922_mini.c:185: TR1=1;
   01AA D2 8E               816 	setb	_TCON_6
                            817 ;	../fb_lpc922_mini.c:186: fb_state=4;							// nächster state: timeout = Telegramm fertig
   01AC 75*2A 04            818 	mov	_fb_state,#0x04
                            819 ;	../fb_lpc922_mini.c:187: EX1=1;								// int1 aktiv, falls noch ein Byte kommt
   01AF D2 AA               820 	setb	_IEN0_2
   01B1 02s03r5D            821 	ljmp	00219$
   01B4                     822 00138$:
                            823 ;	../fb_lpc922_mini.c:189: else init_rx();							// irgendwas empfangen
   01B4 12s03r7C            824 	lcall	_init_rx
                            825 ;	../fb_lpc922_mini.c:193: break;
   01B7 02s03r5D            826 	ljmp	00219$
                            827 ;	../fb_lpc922_mini.c:195: case 3: // T=104us=0us
   01BA                     828 00151$:
                            829 ;	../fb_lpc922_mini.c:196: TH1=128;// reload auf 35µs (Zeit zwischen State 2 und 3)
   01BA 75 8D 80            830 	mov	_TH1,#0x80
                            831 ;	../fb_lpc922_mini.c:197: fb_state=2;//1
   01BD 75*2A 02            832 	mov	_fb_state,#0x02
                            833 ;	../fb_lpc922_mini.c:198: break;
   01C0 02s03r5D            834 	ljmp	00219$
                            835 ;	../fb_lpc922_mini.c:200: case 4:	//	Timeout, d.h. Telegramm-Ende
   01C3                     836 00152$:
                            837 ;	../fb_lpc922_mini.c:201: if (auto_ack && telpos>4) {		// wenn ACK gesendet werden soll und Telegramm zumindest 5 Bytes hat
   01C3 20*08 03            838 	jb	_auto_ack,00349$
   01C6 02s02r3A            839 	ljmp	00172$
   01C9                     840 00349$:
   01C9 E5*26               841 	mov	a,_telpos
   01CB 24 FB               842 	add	a,#0xff - 0x04
   01CD 50 6B               843 	jnc	00172$
                            844 ;	../fb_lpc922_mini.c:202: TR1=0;
   01CF C2 8E               845 	clr	_TCON_6
                            846 ;	../fb_lpc922_mini.c:203: TMOD=(TMOD & 0x0F) +0x10;	// Timer 1 als 16-Bit Timer
   01D1 74 0F               847 	mov	a,#0x0F
   01D3 55 89               848 	anl	a,_TMOD
   01D5 24 10               849 	add	a,#0x10
   01D7 F5 89               850 	mov	_TMOD,a
                            851 ;	../fb_lpc922_mini.c:204: TH1=0xEF;					// Timer 1 auf ACK-Position setzen (15 Bit Pause = 2708µs (26 Bit) nach Beginn Startbit vom letzten Datenbyte)
   01D9 75 8D EF            852 	mov	_TH1,#0xEF
                            853 ;	../fb_lpc922_mini.c:205: TL1=0x42;
   01DC 75 8B 42            854 	mov	_TL1,#0x42
                            855 ;	../fb_lpc922_mini.c:206: TR1=1;
   01DF D2 8E               856 	setb	_TCON_6
                            857 ;	../fb_lpc922_mini.c:207: its_me=transparency;			// indiziert, ob dieses Gerät adressiert wurde, bei transparecy=1 immer
   01E1 A2*0D               858 	mov	c,_transparency
   01E3 92*05               859 	mov	_its_me,c
                            860 ;	../fb_lpc922_mini.c:208: if(telegramm[5]&0x80) {
   01E5 E5*0C               861 	mov	a,(_telegramm + 0x0005)
   01E7 30 E7 1F            862 	jnb	acc.7,00162$
                            863 ;	../fb_lpc922_mini.c:209: if (gapos_in_gat(telegramm[3],telegramm[4])!=0xFF) its_me=1;	// Gruppenadresse
   01EA 85*0A 82            864 	mov	dpl,(_telegramm + 0x0003)
   01ED C0*0B               865 	push	(_telegramm + 0x0004)
   01EF 12s00r00            866 	lcall	_gapos_in_gat
   01F2 AF 82               867 	mov	r7,dpl
   01F4 15 81               868 	dec	sp
   01F6 BF FF 02            869 	cjne	r7,#0xFF,00352$
   01F9 80 02               870 	sjmp	00154$
   01FB                     871 00352$:
   01FB D2*05               872 	setb	_its_me
   01FD                     873 00154$:
                            874 ;	../fb_lpc922_mini.c:210: if (telegramm[3]==0 && telegramm[4]==0) its_me=1;				// Broadcast
   01FD E5*0A               875 	mov	a,(_telegramm + 0x0003)
   01FF 70 1C               876 	jnz	00163$
   0201 E5*0B               877 	mov	a,(_telegramm + 0x0004)
   0203 70 18               878 	jnz	00163$
   0205 D2*05               879 	setb	_its_me
   0207 80 14               880 	sjmp	00163$
   0209                     881 00162$:
                            882 ;	../fb_lpc922_mini.c:212: else if(telegramm[3]==eeprom[ADDRTAB+1] && telegramm[4]==eeprom[ADDRTAB+2]) its_me=1;	// phys. Adresse
   0209 90 1D 17            883 	mov	dptr,#(_eeprom + 0x0017)
   020C E4                  884 	clr	a
   020D 93                  885 	movc	a,@a+dptr
   020E FF                  886 	mov	r7,a
   020F B5*0A 0B            887 	cjne	a,(_telegramm + 0x0003),00163$
   0212 90 1D 18            888 	mov	dptr,#(_eeprom + 0x0018)
   0215 E4                  889 	clr	a
   0216 93                  890 	movc	a,@a+dptr
   0217 FF                  891 	mov	r7,a
   0218 B5*0B 02            892 	cjne	a,(_telegramm + 0x0004),00163$
   021B D2*05               893 	setb	_its_me
   021D                     894 00163$:
                            895 ;	../fb_lpc922_mini.c:213: if ((cs==0xFF) && its_me) tel_arrived=1;
   021D 74 FF               896 	mov	a,#0xFF
   021F B5*27 04            897 	cjne	a,_cs,00359$
   0222 74 01               898 	mov	a,#0x01
   0224 80 01               899 	sjmp	00360$
   0226                     900 00359$:
   0226 E4                  901 	clr	a
   0227                     902 00360$:
   0227 FF                  903 	mov	r7,a
   0228 60 05               904 	jz	00165$
   022A 30*05 02            905 	jnb	_its_me,00165$
   022D D2*06               906 	setb	_tel_arrived
   022F                     907 00165$:
                            908 ;	../fb_lpc922_mini.c:214: if ((cs==0xFF)) tel_arrived=1;
   022F EF                  909 	mov	a,r7
   0230 60 02               910 	jz	00168$
   0232 D2*06               911 	setb	_tel_arrived
   0234                     912 00168$:
                            913 ;	../fb_lpc922_mini.c:215: fb_state=5;					// nächster state: ACK-Position erreicht
   0234 75*2A 05            914 	mov	_fb_state,#0x05
   0237 02s03r5D            915 	ljmp	00219$
   023A                     916 00172$:
                            917 ;	../fb_lpc922_mini.c:219: if (telpos>1) tel_arrived=1;	// trotzdem den Eingang eines Telegramms anzeigen
   023A E5*26               918 	mov	a,_telpos
   023C 24 FE               919 	add	a,#0xff - 0x01
   023E 50 02               920 	jnc	00170$
   0240 D2*06               921 	setb	_tel_arrived
   0242                     922 00170$:
                            923 ;	../fb_lpc922_mini.c:220: init_rx();						// wieder in den Empfang zurück
   0242 12s03r7C            924 	lcall	_init_rx
                            925 ;	../fb_lpc922_mini.c:222: break;
   0245 02s03r5D            926 	ljmp	00219$
                            927 ;	../fb_lpc922_mini.c:224: case 5:	// ACK-Position erreicht
   0248                     928 00175$:
                            929 ;	../fb_lpc922_mini.c:225: TR1=0;
   0248 C2 8E               930 	clr	_TCON_6
                            931 ;	../fb_lpc922_mini.c:226: if (cs==0xFF) {	// Checksum OK
   024A 74 FF               932 	mov	a,#0xFF
   024C B5*27 13            933 	cjne	a,_cs,00180$
                            934 ;	../fb_lpc922_mini.c:227: if (its_me) {					// Gerät adressiert
   024F 30*05 0A            935 	jnb	_its_me,00177$
                            936 ;	../fb_lpc922_mini.c:228: send_ack=1;
   0252 D2*0B               937 	setb	_send_ack
                            938 ;	../fb_lpc922_mini.c:229: init_tx();						// Senden initiieren
   0254 12s03rA8            939 	lcall	_init_tx
                            940 ;	../fb_lpc922_mini.c:230: wait_for_ack=0;					// bei ACK senden nicht erneut auf ACK warten
   0257 C2*0A               941 	clr	_wait_for_ack
   0259 02s03r5D            942 	ljmp	00219$
   025C                     943 00177$:
                            944 ;	../fb_lpc922_mini.c:232: else init_rx();					// Gerät nicht adressiert, also zurück zu Empfang
   025C 12s03r7C            945 	lcall	_init_rx
   025F 02s03r5D            946 	ljmp	00219$
   0262                     947 00180$:
                            948 ;	../fb_lpc922_mini.c:235: send_nack=1;
   0262 D2*0C               949 	setb	_send_nack
                            950 ;	../fb_lpc922_mini.c:236: init_tx();
   0264 12s03rA8            951 	lcall	_init_tx
                            952 ;	../fb_lpc922_mini.c:237: wait_for_ack=0;					// bei NACK senden nicht erneut auf ACK warten
   0267 C2*0A               953 	clr	_wait_for_ack
                            954 ;	../fb_lpc922_mini.c:239: break;
   0269 02s03r5D            955 	ljmp	00219$
                            956 ;	../fb_lpc922_mini.c:243: case 10:	// Byte Senden, T=0us
   026C                     957 00182$:
                            958 ;	../fb_lpc922_mini.c:244: send_byte=telegramm[telpos];
   026C E5*26               959 	mov	a,_telpos
   026E 24r07               960 	add	a,#_telegramm
   0270 F9                  961 	mov	r1,a
   0271 87 07               962 	mov	ar7,@r1
                            963 ;	../fb_lpc922_mini.c:245: if (send_ack) send_byte=0xCC;
   0273 30*0B 02            964 	jnb	_send_ack,00184$
   0276 7F CC               965 	mov	r7,#0xCC
   0278                     966 00184$:
                            967 ;	../fb_lpc922_mini.c:246: if (send_nack) send_byte=0x0C;
   0278 30*0C 02            968 	jnb	_send_nack,00186$
   027B 7F 0C               969 	mov	r7,#0x0C
   027D                     970 00186$:
                            971 ;	../fb_lpc922_mini.c:247: EX1=0;					// Empfang verhindern
   027D C2 AA               972 	clr	_IEN0_2
                            973 ;	../fb_lpc922_mini.c:248: if(fb_state==10){
   027F 74 0A               974 	mov	a,#0x0A
   0281 B5*2A 02            975 	cjne	a,_fb_state,00370$
   0284 80 03               976 	sjmp	00371$
   0286                     977 00370$:
   0286 02s03r5D            978 	ljmp	00219$
   0289                     979 00371$:
                            980 ;	../fb_lpc922_mini.c:249: if (fb_pattern<=128) {			// Startbit und Datenbits (pattern=0:startbit, 1 2 4 8 .. 128 Datenbits, 129 parity)
   0289 E5*29               981 	mov	a,_fb_pattern
   028B 24 7F               982 	add	a,#0xff - 0x80
   028D 40 2C               983 	jc	00199$
                            984 ;	../fb_lpc922_mini.c:250: if ((send_byte & fb_pattern)==0) {	// wenn Bit logisch 0 ist
   028F E5*29               985 	mov	a,_fb_pattern
   0291 5F                  986 	anl	a,r7
   0292 70 08               987 	jnz	00188$
                            988 ;	../fb_lpc922_mini.c:251: FBOUTC=1;						// Bus runter ziehen
   0294 D2 96               989 	setb	_P1_6
                            990 ;	../fb_lpc922_mini.c:252: fbtx_bit=0;						// fbtx_bit dient zur späteren Kollisionsprüfung
   0296 C2*09               991 	clr	_fbtx_bit
                            992 ;	../fb_lpc922_mini.c:253: fb_parity=!fb_parity;			// Parity-Bit berechnen
   0298 B2*02               993 	cpl	_fb_parity
   029A 80 02               994 	sjmp	00189$
   029C                     995 00188$:
                            996 ;	../fb_lpc922_mini.c:255: else fbtx_bit=1;
   029C D2*09               997 	setb	_fbtx_bit
   029E                     998 00189$:
                            999 ;	../fb_lpc922_mini.c:256: if (fb_pattern==0) {				// wenn Startbit: parity zurücksetzen
   029E E5*29              1000 	mov	a,_fb_pattern
   02A0 70 07              1001 	jnz	00191$
                           1002 ;	../fb_lpc922_mini.c:257: fb_pattern=1;					// auf erstes Datenbit zeigen
   02A2 75*29 01           1003 	mov	_fb_pattern,#0x01
                           1004 ;	../fb_lpc922_mini.c:258: fb_parity=0;
   02A5 C2*02              1005 	clr	_fb_parity
   02A7 80 06              1006 	sjmp	00192$
   02A9                    1007 00191$:
                           1008 ;	../fb_lpc922_mini.c:260: else fb_pattern=fb_pattern<<1;		// nächstes Datenbit
   02A9 E5*29              1009 	mov	a,_fb_pattern
   02AB 25*29              1010 	add	a,_fb_pattern
   02AD F5*29              1011 	mov	_fb_pattern,a
   02AF                    1012 00192$:
                           1013 ;	../fb_lpc922_mini.c:261: if(fb_pattern==0) fb_pattern=129;	// alle Daten-Bits gesendet, Parity-Bit folgt
   02AF E5*29              1014 	mov	a,_fb_pattern
   02B1 70 03              1015 	jnz	00194$
   02B3 75*29 81           1016 	mov	_fb_pattern,#0x81
   02B6                    1017 00194$:
                           1018 ;	../fb_lpc922_mini.c:262: fb_state=11;
   02B6 75*2A 0B           1019 	mov	_fb_state,#0x0B
   02B9 80 13              1020 	sjmp	00200$
   02BB                    1021 00199$:
                           1022 ;	../fb_lpc922_mini.c:265: if (!fb_parity) {				// wenn Parity-Bit logisch 0
   02BB 20*02 06           1023 	jb	_fb_parity,00196$
                           1024 ;	../fb_lpc922_mini.c:266: FBOUTC=1;						// Bus runterziehen
   02BE D2 96              1025 	setb	_P1_6
                           1026 ;	../fb_lpc922_mini.c:267: fbtx_bit=0;						// fbtx_bit dient zur späteren Kollisionsprüfung
   02C0 C2*09              1027 	clr	_fbtx_bit
   02C2 80 02              1028 	sjmp	00197$
   02C4                    1029 00196$:
                           1030 ;	../fb_lpc922_mini.c:269: else fbtx_bit=1;
   02C4 D2*09              1031 	setb	_fbtx_bit
   02C6                    1032 00197$:
                           1033 ;	../fb_lpc922_mini.c:270: telpos++;					// nächstes Byte
   02C6 05*26              1034 	inc	_telpos
                           1035 ;	../fb_lpc922_mini.c:271: fb_pattern=0;				// wieder mit Startbit beginnen
   02C8 75*29 00           1036 	mov	_fb_pattern,#0x00
                           1037 ;	../fb_lpc922_mini.c:272: fb_state=13;				// Prüfen ob Telegramm fertig
   02CB 75*2A 0D           1038 	mov	_fb_state,#0x0D
   02CE                    1039 00200$:
                           1040 ;	../fb_lpc922_mini.c:274: TH1=18; //reload 70µ -delay interrupt (von state 11 auf 13)
   02CE 75 8D 12           1041 	mov	_TH1,#0x12
                           1042 ;	../fb_lpc922_mini.c:276: break;
   02D1 02s03r5D           1043 	ljmp	00219$
                           1044 ;	../fb_lpc922_mini.c:278: case 11:	// Sendestufe aus, T=35us
   02D4                    1045 00203$:
                           1046 ;	../fb_lpc922_mini.c:279: if(telpos==0 && fb_pattern==1) {	// 1. Byte Startbit
   02D4 E5*26              1047 	mov	a,_telpos
   02D6 70 07              1048 	jnz	00205$
   02D8 74 01              1049 	mov	a,#0x01
   02DA B5*29 02           1050 	cjne	a,_fb_pattern,00205$
                           1051 ;	../fb_lpc922_mini.c:280: repeat_count++;		// angefangener Sendeversuch, also Zähler erhöhen
   02DD 05*2B              1052 	inc	_repeat_count
   02DF                    1053 00205$:
                           1054 ;	../fb_lpc922_mini.c:282: FBOUTC=0;				// Sendestufe aus
   02DF C2 96              1055 	clr	_P1_6
                           1056 ;	../fb_lpc922_mini.c:283: if (fbtx_bit & IE1) {	// Kollision
   02E1 A2*09              1057 	mov	c,_fbtx_bit
   02E3 82 8B              1058 	anl	c,_TCON_3
   02E5 50 07              1059 	jnc	00208$
                           1060 ;	../fb_lpc922_mini.c:284: wait_for_ack=0;
   02E7 C2*0A              1061 	clr	_wait_for_ack
                           1062 ;	../fb_lpc922_mini.c:285: init_rx();				// Senden abbrechen und Empfang initialisieren
   02E9 12s03r7C           1063 	lcall	_init_rx
   02EC 80 06              1064 	sjmp	00209$
   02EE                    1065 00208$:
                           1066 ;	../fb_lpc922_mini.c:288: fb_state=10;//12;
   02EE 75*2A 0A           1067 	mov	_fb_state,#0x0A
                           1068 ;	../fb_lpc922_mini.c:289: TH1=110;// 35µs + delay (von state 10 auf 11)
   02F1 75 8D 6E           1069 	mov	_TH1,#0x6E
   02F4                    1070 00209$:
                           1071 ;	../fb_lpc922_mini.c:291: IE1=0;					// Flipflop löschen
   02F4 C2 8B              1072 	clr	_TCON_3
                           1073 ;	../fb_lpc922_mini.c:292: break;
                           1074 ;	../fb_lpc922_mini.c:298: case 13:	// Byte übertragen, T=35us, prüfen ob Telegramm fertig
   02F6 80 65              1075 	sjmp	00219$
   02F8                    1076 00210$:
                           1077 ;	../fb_lpc922_mini.c:299: FBOUTC=0;
   02F8 C2 96              1078 	clr	_P1_6
                           1079 ;	../fb_lpc922_mini.c:300: TR1=0;
   02FA C2 8E              1080 	clr	_TCON_6
                           1081 ;	../fb_lpc922_mini.c:301: TMOD=(TMOD & 0x0F) +0x10;	// Timer 1 als 16-Bit Timer
   02FC 74 0F              1082 	mov	a,#0x0F
   02FE 55 89              1083 	anl	a,_TMOD
   0300 24 10              1084 	add	a,#0x10
   0302 F5 89              1085 	mov	_TMOD,a
                           1086 ;	../fb_lpc922_mini.c:302: TH1=0xFB;					// Timer 1 auf Interbyte Abstand setzen (3 Bit Pause = 312µs 
   0304 75 8D FB           1087 	mov	_TH1,#0xFB
                           1088 ;	../fb_lpc922_mini.c:303: TL1=0x90;
   0307 75 8B 90           1089 	mov	_TL1,#0x90
                           1090 ;	../fb_lpc922_mini.c:304: TR1=1;
   030A D2 8E              1091 	setb	_TCON_6
                           1092 ;	../fb_lpc922_mini.c:305: if (send_ack || send_nack) {	// ACK/NACK senden
   030C 20*0B 03           1093 	jb	_send_ack,00214$
   030F 30*0C 05           1094 	jnb	_send_nack,00215$
   0312                    1095 00214$:
                           1096 ;	../fb_lpc922_mini.c:306: init_rx();					// ACK senden abgeschlossen, also statemachine auf Anfang
   0312 12s03r7C           1097 	lcall	_init_rx
   0315 80 2B              1098 	sjmp	00216$
   0317                    1099 00215$:
                           1100 ;	../fb_lpc922_mini.c:309: if (telpos>((telegramm[5]&0x0F)+7)) {		// Telegramm fertig gesendet
   0317 74 0F              1101 	mov	a,#0x0F
   0319 55*0C              1102 	anl	a,(_telegramm + 0x0005)
   031B FF                 1103 	mov	r7,a
   031C 7E 00              1104 	mov	r6,#0x00
   031E 74 07              1105 	mov	a,#0x07
   0320 2F                 1106 	add	a,r7
   0321 FF                 1107 	mov	r7,a
   0322 E4                 1108 	clr	a
   0323 3E                 1109 	addc	a,r6
   0324 FE                 1110 	mov	r6,a
   0325 AC*26              1111 	mov	r4,_telpos
   0327 7D 00              1112 	mov	r5,#0x00
   0329 C3                 1113 	clr	c
   032A EF                 1114 	mov	a,r7
   032B 9C                 1115 	subb	a,r4
   032C EE                 1116 	mov	a,r6
   032D 64 80              1117 	xrl	a,#0x80
   032F 8D F0              1118 	mov	b,r5
   0331 63 F0 80           1119 	xrl	b,#0x80
   0334 95 F0              1120 	subb	a,b
   0336 50 07              1121 	jnc	00212$
                           1122 ;	../fb_lpc922_mini.c:310: tel_sent=1;
   0338 D2*07              1123 	setb	_tel_sent
                           1124 ;	../fb_lpc922_mini.c:311: init_rx();	// Telegramm senden abgeschlossen, ggf. wiederholen wenn nicht geackt wird
   033A 12s03r7C           1125 	lcall	_init_rx
   033D 80 03              1126 	sjmp	00216$
   033F                    1127 00212$:
                           1128 ;	../fb_lpc922_mini.c:313: else fb_state=14;		// nächstes Byte: Interbyte Abstand einhalten
   033F 75*2A 0E           1129 	mov	_fb_state,#0x0E
   0342                    1130 00216$:
                           1131 ;	../fb_lpc922_mini.c:315: IE1=0;
   0342 C2 8B              1132 	clr	_TCON_3
                           1133 ;	../fb_lpc922_mini.c:316: break;
                           1134 ;	../fb_lpc922_mini.c:318: case 14:	// Interbyte Abstand erreicht (=Stopbit + 2 Bit)
   0344 80 17              1135 	sjmp	00219$
   0346                    1136 00218$:
                           1137 ;	../fb_lpc922_mini.c:319: TR1=0;
   0346 C2 8E              1138 	clr	_TCON_6
                           1139 ;	../fb_lpc922_mini.c:320: TMOD=(TMOD & 0x0F) +0x20;			// Timer 1 als 8-Bit autoreload
   0348 74 0F              1140 	mov	a,#0x0F
   034A 55 89              1141 	anl	a,_TMOD
   034C 24 20              1142 	add	a,#0x20
   034E F5 89              1143 	mov	_TMOD,a
                           1144 ;	../fb_lpc922_mini.c:321: TH1=110;							// Timer 1 auf 104/3 us laden
   0350 75 8D 6E           1145 	mov	_TH1,#0x6E
                           1146 ;	../fb_lpc922_mini.c:322: TL1=128;
   0353 75 8B 80           1147 	mov	_TL1,#0x80
                           1148 ;	../fb_lpc922_mini.c:323: TF1=0;
   0356 C2 8F              1149 	clr	_TCON_7
                           1150 ;	../fb_lpc922_mini.c:324: TR1=1;
   0358 D2 8E              1151 	setb	_TCON_6
                           1152 ;	../fb_lpc922_mini.c:325: fb_state=10;
   035A 75*2A 0A           1153 	mov	_fb_state,#0x0A
                           1154 ;	../fb_lpc922_mini.c:330: }
   035D                    1155 00219$:
                           1156 ;	../fb_lpc922_mini.c:331: interrupted=1;			// zeigt der app, dass sie unterbrochen wurde
   035D D2*01              1157 	setb	_interrupted
   035F D0 D0              1158 	pop	psw
   0361 D0 00              1159 	pop	(0+0)
   0363 D0 01              1160 	pop	(0+1)
   0365 D0 02              1161 	pop	(0+2)
   0367 D0 03              1162 	pop	(0+3)
   0369 D0 04              1163 	pop	(0+4)
   036B D0 05              1164 	pop	(0+5)
   036D D0 06              1165 	pop	(0+6)
   036F D0 07              1166 	pop	(0+7)
   0371 D0 83              1167 	pop	dph
   0373 D0 82              1168 	pop	dpl
   0375 D0 F0              1169 	pop	b
   0377 D0 E0              1170 	pop	acc
   0379 D0*00              1171 	pop	bits
   037B 32                 1172 	reti
                           1173 ;------------------------------------------------------------
                           1174 ;Allocation info for local variables in function 'init_rx'
                           1175 ;------------------------------------------------------------
                           1176 ;	../fb_lpc922_mini.c:335: void init_rx(void) 	// Empfangen initiieren (statemachine auf Anfang)
                           1177 ;	-----------------------------------------
                           1178 ;	 function init_rx
                           1179 ;	-----------------------------------------
   037C                    1180 _init_rx:
                           1181 ;	../fb_lpc922_mini.c:337: fb_state=0;
   037C 75*2A 00           1182 	mov	_fb_state,#0x00
                           1183 ;	../fb_lpc922_mini.c:338: IE1=0;
   037F C2 8B              1184 	clr	_TCON_3
                           1185 ;	../fb_lpc922_mini.c:339: TR1=0;
   0381 C2 8E              1186 	clr	_TCON_6
                           1187 ;	../fb_lpc922_mini.c:340: ET1=0;
   0383 C2 AB              1188 	clr	_IEN0_3
                           1189 ;	../fb_lpc922_mini.c:341: cs=0;
   0385 75*27 00           1190 	mov	_cs,#0x00
                           1191 ;	../fb_lpc922_mini.c:342: telpos=0;
   0388 75*26 00           1192 	mov	_telpos,#0x00
                           1193 ;	../fb_lpc922_mini.c:343: TR1=0;
   038B C2 8E              1194 	clr	_TCON_6
                           1195 ;	../fb_lpc922_mini.c:344: TMOD=(TMOD & 0x0F) +0x10;	// Timer 1 als 16-Bit Timer
   038D 74 0F              1196 	mov	a,#0x0F
   038F 55 89              1197 	anl	a,_TMOD
   0391 24 10              1198 	add	a,#0x10
   0393 F5 89              1199 	mov	_TMOD,a
                           1200 ;	../fb_lpc922_mini.c:345: TH1=0x89;					// busfree Zeit = 15 Bit (auf ACK) + 11 Bit (ACK) + 53 Bit
   0395 75 8D 89           1201 	mov	_TH1,#0x89
                           1202 ;	../fb_lpc922_mini.c:346: TL1=0xAF;
   0398 75 8B AF           1203 	mov	_TL1,#0xAF
                           1204 ;	../fb_lpc922_mini.c:347: send_ack=0;
   039B C2*0B              1205 	clr	_send_ack
                           1206 ;	../fb_lpc922_mini.c:348: send_nack=0;
   039D C2*0C              1207 	clr	_send_nack
                           1208 ;	../fb_lpc922_mini.c:349: TF1=0;
   039F C2 8F              1209 	clr	_TCON_7
                           1210 ;	../fb_lpc922_mini.c:350: TR1=1;
   03A1 D2 8E              1211 	setb	_TCON_6
                           1212 ;	../fb_lpc922_mini.c:351: EX1=1;
   03A3 D2 AA              1213 	setb	_IEN0_2
                           1214 ;	../fb_lpc922_mini.c:352: ET1=1;
   03A5 D2 AB              1215 	setb	_IEN0_3
   03A7 22                 1216 	ret
                           1217 ;------------------------------------------------------------
                           1218 ;Allocation info for local variables in function 'init_tx'
                           1219 ;------------------------------------------------------------
                           1220 ;n                         Allocated to registers r6 
                           1221 ;cs_pos                    Allocated to registers r7 
                           1222 ;------------------------------------------------------------
                           1223 ;	../fb_lpc922_mini.c:356: void init_tx(void) 		// Checksum des Telegramms berechnen und Senden initiieren
                           1224 ;	-----------------------------------------
                           1225 ;	 function init_tx
                           1226 ;	-----------------------------------------
   03A8                    1227 _init_tx:
                           1228 ;	../fb_lpc922_mini.c:360: TR1=0;
   03A8 C2 8E              1229 	clr	_TCON_6
                           1230 ;	../fb_lpc922_mini.c:361: TMOD=(TMOD & 0x0F) +0x20;			// Timer 1 als 8-Bit autoreload
   03AA 74 0F              1231 	mov	a,#0x0F
   03AC 55 89              1232 	anl	a,_TMOD
   03AE 24 20              1233 	add	a,#0x20
   03B0 F5 89              1234 	mov	_TMOD,a
                           1235 ;	../fb_lpc922_mini.c:362: TH1=110;							// von state 10 auf 11
   03B2 75 8D 6E           1236 	mov	_TH1,#0x6E
                           1237 ;	../fb_lpc922_mini.c:363: TL1=128;							// von hier bis state 10
   03B5 75 8B 80           1238 	mov	_TL1,#0x80
                           1239 ;	../fb_lpc922_mini.c:364: TF1=0;
   03B8 C2 8F              1240 	clr	_TCON_7
                           1241 ;	../fb_lpc922_mini.c:366: cs_pos=(telegramm[5]&0x0F)+7;		// Position der Checksum im Telegramm
   03BA 74 0F              1242 	mov	a,#0x0F
   03BC 55*0C              1243 	anl	a,(_telegramm + 0x0005)
   03BE 24 07              1244 	add	a,#0x07
   03C0 FF                 1245 	mov	r7,a
                           1246 ;	../fb_lpc922_mini.c:367: cs=0xFF;
   03C1 75*27 FF           1247 	mov	_cs,#0xFF
                           1248 ;	../fb_lpc922_mini.c:368: for(n=0;n<cs_pos;n++) {
   03C4 7E 00              1249 	mov	r6,#0x00
   03C6                    1250 00101$:
   03C6 C3                 1251 	clr	c
   03C7 EE                 1252 	mov	a,r6
   03C8 9F                 1253 	subb	a,r7
   03C9 50 0B              1254 	jnc	00104$
                           1255 ;	../fb_lpc922_mini.c:369: cs^=telegramm[n];				// Checksum berechnen
   03CB EE                 1256 	mov	a,r6
   03CC 24r07              1257 	add	a,#_telegramm
   03CE F9                 1258 	mov	r1,a
   03CF E7                 1259 	mov	a,@r1
   03D0 FD                 1260 	mov	r5,a
   03D1 62*27              1261 	xrl	_cs,a
                           1262 ;	../fb_lpc922_mini.c:368: for(n=0;n<cs_pos;n++) {
   03D3 0E                 1263 	inc	r6
   03D4 80 F0              1264 	sjmp	00101$
   03D6                    1265 00104$:
                           1266 ;	../fb_lpc922_mini.c:371: telegramm[cs_pos]=cs;				// Checksum hinter Nutzdaten anfügen
   03D6 EF                 1267 	mov	a,r7
   03D7 24r07              1268 	add	a,#_telegramm
   03D9 F8                 1269 	mov	r0,a
   03DA A6*27              1270 	mov	@r0,_cs
                           1271 ;	../fb_lpc922_mini.c:372: ack=0;
   03DC C2*03              1272 	clr	_ack
                           1273 ;	../fb_lpc922_mini.c:373: nack=0;
   03DE C2*04              1274 	clr	_nack
                           1275 ;	../fb_lpc922_mini.c:374: wait_for_ack=1;
   03E0 D2*0A              1276 	setb	_wait_for_ack
                           1277 ;	../fb_lpc922_mini.c:376: fb_state=10;						// nächster state: senden
   03E2 75*2A 0A           1278 	mov	_fb_state,#0x0A
                           1279 ;	../fb_lpc922_mini.c:377: fb_pattern=0;						// nächstes zu sendendes Bit, 0=Startbit
   03E5 75*29 00           1280 	mov	_fb_pattern,#0x00
                           1281 ;	../fb_lpc922_mini.c:378: telpos=0;							// nächstes zu sendende Byte
   03E8 75*26 00           1282 	mov	_telpos,#0x00
                           1283 ;	../fb_lpc922_mini.c:380: EX1=0;								// ext. int1 inaktiv
   03EB C2 AA              1284 	clr	_IEN0_2
                           1285 ;	../fb_lpc922_mini.c:381: TR1=1;								// Timer 1 starten
   03ED D2 8E              1286 	setb	_TCON_6
                           1287 ;	../fb_lpc922_mini.c:382: ET1=1;								// Timer 1 int. aktiv
   03EF D2 AB              1288 	setb	_IEN0_3
   03F1 22                 1289 	ret
                           1290 ;------------------------------------------------------------
                           1291 ;Allocation info for local variables in function 'send_obj_value'
                           1292 ;------------------------------------------------------------
                           1293 ;objno                     Allocated to registers r7 
                           1294 ;success                   Allocated to registers b0 
                           1295 ;------------------------------------------------------------
                           1296 ;	../fb_lpc922_mini.c:410: __bit send_obj_value(unsigned char objno)
                           1297 ;	-----------------------------------------
                           1298 ;	 function send_obj_value
                           1299 ;	-----------------------------------------
   03F2                    1300 _send_obj_value:
   03F2 AF 82              1301 	mov	r7,dpl
                           1302 ;	../fb_lpc922_mini.c:412: __bit success=0;
   03F4 C2*00              1303 	clr	b0
                           1304 ;	../fb_lpc922_mini.c:414: if(tx_nextsend!=((tx_nextwrite+1)&0x07)) {
   03F6 AD*2C              1305 	mov	r5,_tx_nextwrite
   03F8 7E 00              1306 	mov	r6,#0x00
   03FA 0D                 1307 	inc	r5
   03FB BD 00 01           1308 	cjne	r5,#0x00,00107$
   03FE 0E                 1309 	inc	r6
   03FF                    1310 00107$:
   03FF 53 05 07           1311 	anl	ar5,#0x07
   0402 7E 00              1312 	mov	r6,#0x00
   0404 AB*2D              1313 	mov	r3,_tx_nextsend
   0406 7C 00              1314 	mov	r4,#0x00
   0408 EB                 1315 	mov	a,r3
   0409 B5 05 06           1316 	cjne	a,ar5,00108$
   040C EC                 1317 	mov	a,r4
   040D B5 06 02           1318 	cjne	a,ar6,00108$
   0410 80 0E              1319 	sjmp	00102$
   0412                    1320 00108$:
                           1321 ;	../fb_lpc922_mini.c:415: tx_buffer[tx_nextwrite]=objno;
   0412 E5*2C              1322 	mov	a,_tx_nextwrite
   0414 24r1E              1323 	add	a,#_tx_buffer
   0416 F8                 1324 	mov	r0,a
   0417 A6 07              1325 	mov	@r0,ar7
                           1326 ;	../fb_lpc922_mini.c:416: tx_nextwrite++;
   0419 05*2C              1327 	inc	_tx_nextwrite
                           1328 ;	../fb_lpc922_mini.c:417: tx_nextwrite&=0x07;
   041B 53*2C 07           1329 	anl	_tx_nextwrite,#0x07
                           1330 ;	../fb_lpc922_mini.c:418: success=1;
   041E D2*00              1331 	setb	b0
   0420                    1332 00102$:
                           1333 ;	../fb_lpc922_mini.c:420: TR1=1;	// statemachine starten falls vorher in state 0 gestoppt
   0420 D2 8E              1334 	setb	_TCON_6
                           1335 ;	../fb_lpc922_mini.c:421: return(success);
   0422 A2*00              1336 	mov	c,b0
   0424 22                 1337 	ret
                           1338 ;------------------------------------------------------------
                           1339 ;Allocation info for local variables in function 'process_tel'
                           1340 ;------------------------------------------------------------
                           1341 ;tpdu                      Allocated to registers r7 
                           1342 ;apdu                      Allocated to registers r6 
                           1343 ;------------------------------------------------------------
                           1344 ;	../fb_lpc922_mini.c:427: void process_tel(void)
                           1345 ;	-----------------------------------------
                           1346 ;	 function process_tel
                           1347 ;	-----------------------------------------
   0425                    1348 _process_tel:
                           1349 ;	../fb_lpc922_mini.c:431: tel_arrived=0;
   0425 C2*06              1350 	clr	_tel_arrived
                           1351 ;	../fb_lpc922_mini.c:432: tpdu=telegramm[6]&0xC3;
   0427 74 C3              1352 	mov	a,#0xC3
   0429 55*0D              1353 	anl	a,(_telegramm + 0x0006)
   042B FF                 1354 	mov	r7,a
                           1355 ;	../fb_lpc922_mini.c:433: apdu=telegramm[7];
   042C AE*0E              1356 	mov	r6,(_telegramm + 0x0007)
                           1357 ;	../fb_lpc922_mini.c:436: if(telegramm[3]==0 && telegramm[4]==0) {	// nur wenn wenn Zieladresse = 0
   042E E5*0A              1358 	mov	a,(_telegramm + 0x0003)
   0430 70 04              1359 	jnz	00112$
   0432 E5*0B              1360 	mov	a,(_telegramm + 0x0004)
   0434 60 25              1361 	jz	00115$
   0436                    1362 00112$:
                           1363 ;	../fb_lpc922_mini.c:444: if((telegramm[5]&0x80)==0x00) {	// Destination Adress Flag Bit 7, 0=phys. Adr., 1=Gruppenadr.
   0436 E5*0C              1364 	mov	a,(_telegramm + 0x0005)
   0438 30 E7 20           1365 	jnb	acc.7,00115$
                           1366 ;	../fb_lpc922_mini.c:505: if(tpdu==GROUP_PDU){
   043B EF                 1367 	mov	a,r7
   043C 70 1D              1368 	jnz	00115$
                           1369 ;	../fb_lpc922_mini.c:506: if(((apdu&0xC0)==WRITE_GROUP)||((apdu&0xC0)==0x40)) write_value_req();	// Objektwerte schreiben (zB. EISx)		00000000 10xxxxxx
   043E 74 C0              1370 	mov	a,#0xC0
   0440 5E                 1371 	anl	a,r6
   0441 FF                 1372 	mov	r7,a
   0442 BF 80 02           1373 	cjne	r7,#0x80,00131$
   0445 80 07              1374 	sjmp	00101$
   0447                    1375 00131$:
   0447 74 C0              1376 	mov	a,#0xC0
   0449 5E                 1377 	anl	a,r6
   044A FF                 1378 	mov	r7,a
   044B BF 40 07           1379 	cjne	r7,#0x40,00102$
   044E                    1380 00101$:
   044E C0 06              1381 	push	ar6
   0450 12s00r00           1382 	lcall	_write_value_req
   0453 D0 06              1383 	pop	ar6
   0455                    1384 00102$:
                           1385 ;	../fb_lpc922_mini.c:507: if(apdu==READ_GROUP_REQUEST) read_value_req();	// Objektwert lesen und read_value_response senden	00000000 00000000
   0455 EE                 1386 	mov	a,r6
   0456 70 03              1387 	jnz	00115$
   0458 02s00r00           1388 	ljmp	_read_value_req
   045B                    1389 00115$:
   045B 22                 1390 	ret
                           1391 ;------------------------------------------------------------
                           1392 ;Allocation info for local variables in function 'restart_hw'
                           1393 ;------------------------------------------------------------
                           1394 ;	../fb_lpc922_mini.c:617: void restart_hw(void)
                           1395 ;	-----------------------------------------
                           1396 ;	 function restart_hw
                           1397 ;	-----------------------------------------
   045C                    1398 _restart_hw:
                           1399 ;	../fb_lpc922_mini.c:619: DIVM=0;			// Taktferquenz nicht teilen -> volles Tempo
   045C 75 95 00           1400 	mov	_DIVM,#0x00
                           1401 ;	../fb_lpc922_mini.c:621: P1M1=0x14;		// Port 1 auf quasi-bidirektional,
   045F 75 91 14           1402 	mov	_P1M1,#0x14
                           1403 ;	../fb_lpc922_mini.c:622: P1M2=0x4C;		// ausser P1.2(T0 als PWM Ausgang)=open-drain,
   0462 75 92 4C           1404 	mov	_P1M2,#0x4C
                           1405 ;	../fb_lpc922_mini.c:626: FBOUTC=0;		// Bus-Ausgang auf low
   0465 C2 96              1406 	clr	_P1_6
                           1407 ;	../fb_lpc922_mini.c:628: TMOD=0x21;		// Timer 0 als 16-Bit Timer, Timer 1 als 8 Bit autoreload
   0467 75 89 21           1408 	mov	_TMOD,#0x21
                           1409 ;	../fb_lpc922_mini.c:629: TAMOD=0x00;
   046A 75 8F 00           1410 	mov	_TAMOD,#0x00
                           1411 ;	../fb_lpc922_mini.c:630: TR0=0;			// Timer 0 (zur Verwendung in app) zunaechst stoppen 
   046D C2 8C              1412 	clr	_TCON_4
                           1413 ;	../fb_lpc922_mini.c:631: TR1=0;			// Timer 1 (Empfangs-Timer, nicht in app verwenden!) zunaechst stoppen
   046F C2 8E              1414 	clr	_TCON_6
                           1415 ;	../fb_lpc922_mini.c:632: TH1=128;		// Timer 1 auf 104us/3
   0471 75 8D 80           1416 	mov	_TH1,#0x80
                           1417 ;	../fb_lpc922_mini.c:633: TL1=128;
   0474 75 8B 80           1418 	mov	_TL1,#0x80
                           1419 ;	../fb_lpc922_mini.c:634: TF1=0;
   0477 C2 8F              1420 	clr	_TCON_7
                           1421 ;	../fb_lpc922_mini.c:636: RTCH=0x0E;		// Real Time Clock auf 65ms laden
   0479 75 D2 0E           1422 	mov	_RTCH,#0x0E
                           1423 ;	../fb_lpc922_mini.c:637: RTCL=0xA0;		// (RTC ist ein down-counter mit 128 bit prescaler und osc-clock)
   047C 75 D3 A0           1424 	mov	_RTCL,#0xA0
                           1425 ;	../fb_lpc922_mini.c:638: RTCCON=0x61;	// ... und starten
   047F 75 D1 61           1426 	mov	_RTCCON,#0x61
                           1427 ;	../fb_lpc922_mini.c:640: interrupted=0;	// wird durch die interrupt-routine auf 1 gesetzt
   0482 C2*01              1428 	clr	_interrupted
                           1429 ;	../fb_lpc922_mini.c:641: IEN0=0x00;
   0484 75 A8 00           1430 	mov	_IEN0,#0x00
                           1431 ;	../fb_lpc922_mini.c:642: IEN1=0x00;
   0487 75 E8 00           1432 	mov	_IEN1,#0x00
                           1433 ;	../fb_lpc922_mini.c:644: ET1=0;			// Interrupt von Timer 1 sperren
   048A C2 AB              1434 	clr	_IEN0_3
                           1435 ;	../fb_lpc922_mini.c:645: EX0=0;			// Externen Interrupt 0 sperren
   048C C2 A8              1436 	clr	_IEN0_0
                           1437 ;	../fb_lpc922_mini.c:646: EX1=0;			// Externen Interrupt 1 sperren
   048E C2 AA              1438 	clr	_IEN0_2
                           1439 ;	../fb_lpc922_mini.c:647: EA=1;			// Interrupts prinzipiell freigeben
   0490 D2 AF              1440 	setb	_IEN0_7
                           1441 ;	../fb_lpc922_mini.c:649: IP0=0x04;		// höchste Priorität fuer ext1
   0492 75 B8 04           1442 	mov	_IP0,#0x04
                           1443 ;	../fb_lpc922_mini.c:650: IP0H=0x0C;
   0495 75 B7 0C           1444 	mov	_IP0H,#0x0C
                           1445 ;	../fb_lpc922_mini.c:651: IT1=1;			// Interrupt 1 flankengetriggert=1
   0498 D2 8A              1446 	setb	_TCON_2
                           1447 ;	../fb_lpc922_mini.c:653: status60=0x2E;	// Status-Byte (steht normal im userram an 0x60)
   049A 75*2E 2E           1448 	mov	_status60,#0x2E
                           1449 ;	../fb_lpc922_mini.c:655: ack=0;			// ack und nack flag zurücksetzen
   049D C2*03              1450 	clr	_ack
                           1451 ;	../fb_lpc922_mini.c:656: nack=0;
   049F C2*04              1452 	clr	_nack
                           1453 ;	../fb_lpc922_mini.c:657: send_ack=0;
   04A1 C2*0B              1454 	clr	_send_ack
                           1455 ;	../fb_lpc922_mini.c:658: send_nack=0;
   04A3 C2*0C              1456 	clr	_send_nack
                           1457 ;	../fb_lpc922_mini.c:659: tel_arrived=0;	// kein Telegramm empfangen
   04A5 C2*06              1458 	clr	_tel_arrived
                           1459 ;	../fb_lpc922_mini.c:660: auto_ack=1;		// empfangene Telegramme automatisch mit ack bestätigen
   04A7 D2*08              1460 	setb	_auto_ack
                           1461 ;	../fb_lpc922_mini.c:661: tx_nextwrite=0;	// Zeiger auf nächste zu schreibende Objektnr. in tx_buffer
   04A9 75*2C 00           1462 	mov	_tx_nextwrite,#0x00
                           1463 ;	../fb_lpc922_mini.c:662: tx_nextsend=0;	// Zeiger auf nächste zu sendende Objektnr. in tx_buffer
   04AC 75*2D 00           1464 	mov	_tx_nextsend,#0x00
                           1465 ;	../fb_lpc922_mini.c:663: pcount=0;		// Paketzaehler initialisieren
   04AF 75*02 00           1466 	mov	_pcount,#0x00
                           1467 ;	../fb_lpc922_mini.c:664: inc_pcount=0;
   04B2 C2*0F              1468 	clr	_inc_pcount
                           1469 ;	../fb_lpc922_mini.c:665: connected=0;	// keine Verbindung
   04B4 C2*0E              1470 	clr	_connected
                           1471 ;	../fb_lpc922_mini.c:666: transparency=0;	// fremde Gruppentelegramme werden ignoriert
   04B6 C2*0D              1472 	clr	_transparency
                           1473 ;	../fb_lpc922_mini.c:667: init_rx();		// Empfang initialisieren
   04B8 02s03r7C           1474 	ljmp	_init_rx
                           1475 	.area CSEG    (CODE)
                           1476 	.area CONST   (CODE)
                    1C00   1477 _userram	=	0x1c00
                    1D00   1478 _eeprom	=	0x1d00
                           1479 	.area XINIT   (CODE)
                           1480 	.area CABS    (ABS,CODE)
